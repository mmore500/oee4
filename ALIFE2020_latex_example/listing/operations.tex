\section{Operations}

% create command to draw operation tables
\newcommand{\opdef}[2]{
    \begin{tabular}{|
        >{\columncolor[HTML]{C0C0C0}}l |l|}
        \hline
        Prevalence & #1 \\ \hline
        Num Args   & #2 \\ \hline
    \end{tabular}
}

See \url{https://github.com/mmore500/dishtiny/tree/prq49/include/dish2/operations} and \url{https://github.com/mmore500/signalgp-lite/tree/b6c437f44136651aa6f4051d84bc62a86c2afbbe/include/sgpl/operations}

cpu has X registers and a Y-bit bitstring (64?)

cpu has Z cores (16?)

two matching systems:
* one for internal use with all modules
* one that receives messages from other cells that only contains modules with tags that end in 0

\subsection{Fork If}

\opdef{1}{1}

Requests a fork with the instruction tag as an argument if the register pointed to by the OP argument contains a true value.

\subsection{Nop, 0 RNG Touches}

\opdef{1}{0}

Performs no operation for one CPU cycle.

\subsection{Nop, 1 RNG Touches}

\opdef{1}{0}

Performs no operation for one CPU cycle, and advances the PRNG engine once.

\subsection{Nop, 2 RNG Touches}

\opdef{1}{1}

Performs no operation for one CPU cycle, and advances the PRNG engine twice.

\subsection{Terminate If}

\opdef{1}{1}

Terminates current core if argument is a true value.

\subsection{Add}

\opdef{1}{3}

Adds the value contained in the register pointed to by the second argument to the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Divide}

\opdef{1}{3}

Divides the value contained in the register pointed to by the second argument by the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Modulo}

\opdef{1}{3}

Calculates the remainder of the divison of the value contained in the register pointed to by the second argument by the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Multiply}

\opdef{1}{3}

Multiplies the value contained in the register pointed to by the second argument by the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Subtract}

\opdef{1}{3}

Subtracts the value contained in the register pointed to by the second argument to the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Bitwise And}

\opdef{1}{3}

Performs a bitwise AND of the value contained in the register pointed to by the second argument with the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Bitwise Not}

\opdef{1}{2}

Negates every bit of the value contained in the register pointed to by the second argument.

Stores the result in the register pointed to by the first argument.

\subsection{Bitwise Or}

\opdef{1}{3}

Performs a bitwise OR of the value contained in the register pointed to by the second argument with the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Bitwise Shift}

\opdef{1}{3}

Shifts the bits of the value contained in the register pointed to by the second argument by the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Bitwise Xor}

\opdef{1}{3}

Performs a bitwise XOR of the value contained in the register pointed to by the second argument with the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Count Ones}

\opdef{1}{2}

Counts the number of bits set in the value contained in the register pointed to by the first argument.

Stores the result in the register pointed to by the second argument.

\subsection{Random Fill}

\opdef{1}{1}

Fills register pointed to by the first argument with random bits chosen from a uniform distribution.

\subsection{Equal}

\opdef{1}{3}

Checks whether the value contained in the register pointed to by the second argument is equal to the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Greater Than}

\opdef{1}{3}

Checks whether the value contained in the register pointed to by the second argument is greater than the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Less Than}

\opdef{1}{3}

Checks whether the value contained in the register pointed to by the second argument is less than the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Logical And}

\opdef{1}{3}

Performs a logical AND of the value contained in the register pointed to by the second argument with the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Logical Or}

\opdef{1}{3}

Performs a logical OR of the value contained in the register pointed to by the second argument with the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Not Equal}

\opdef{1}{3}

Checks whether the value contained in the register pointed to by the second argument is not equal to the value in the register pointed to by the third argument.

Stores the result in the register pointed to by the first argument.

\subsection{Global Anchor}

\opdef{15}{0}

Marks a global destination to which any jump instruction may jump to.

\subsection{Global Jump If}

\opdef{1}{1}

Jumps to a global anchor that maches the instruction tag if `arg[0]` is true.

\subsection{Global Jump If Not}

\opdef{1}{1}

Jumps to a global anchor that maches the instruction tag if `arg[0]` is false.

\subsection{Private Regulator Adjust}

\opdef{1}{1}

Adjusts the regulator value of all global jump table tags that match this instruction's tag by `arg[0]`.

\subsection{Private Regulator Decay}

\opdef{1}{1}

Decays the regulator value of all global jump table tags that match this instruction's tag by `arg[0]`.

\subsection{Private Regulator Get}

\opdef{1}{1}

Gets the regulator value of the first global jump table tag that matches this instruction's tag.

Stores it in `arg[0]`.

\subsection{Private Regulator Set}

\opdef{1}{1}

Sets the regulator value of all global jump table tags that match this instruction's tag to `arg[0]`.

\subsection{Local Anchor}

\opdef{20}{0}

Marks a local destination to which any jump instruction may jump to.

At least one local anchor is needed to have a module.

\subsection{Local Jump If}

\opdef{1}{1}

Jumps to a local anchor that maches the instruction tag if `arg[0]` is true.

\subsection{Local Jump If Not}

\opdef{1}{1}

Jumps to a local anchor that maches the instruction tag if `arg[0]` is false.

\subsection{Local Regulator Adjust}

\opdef{1}{1}

Adjusts the regulator value of all local jump table tags that match this instruction's tag by `arg[0]`.

\subsection{Local Regulator Decay}

\opdef{1}{1}

Decays the regulator value of all local jump table tags that match this instruction's tag by `arg[0]`.

\subsection{Local Regulator Get}

\opdef{1}{1}

Gets the regulator value of the first local jump table tag that matches this instruction's tag.

Stores it in `arg[0]`.

\subsection{Local Regulator Set}

\opdef{1}{1}

Sets the regulator value of all local jump table tags that match this instruction's tag to `arg[0]`.

\subsection{Decrement}

\opdef{1}{1}

Takes `arg[0]', decrements it by one, and stores it in `arg[0]'.

\subsection{Increment}

\opdef{1}{1}

Takes `arg[0]', increments it by one, and stores the result in `arg[0]'.

\subsection{Negate}

\opdef{1}{1}

Finds the negative value of `arg[0]` and stores the result in `arg[0]'.

\subsection{Not}

\opdef{1}{1}

Negates `arg[0]` and stores tbe result in `arg[0]'.

\subsection{Random Bool}

\opdef{1}{1}

Stores a random bool on `arg[0]` selected from an uniform distribution with probability proportional to this instruction's tag.

\subsection{Random Draw}

\opdef{1}{1}

Stores a random float on `arg[0]` selected from an uniform distribution with probability proportional to this instruction's tag.

\subsection{Terminal}

\opdef{50}{1}

Stores a genetically-encoded value on `arg[0]`. This value is encoded using the instruction's tag.

\subsection{Exposed Regulator Adjust}

prevalence 1

\subsection{Exposed Regulator Decay}

prevalence 1

\subsection{Exposed Regulator Get}

prevalence 1

\subsection{Exposed Regulator Set}

prevalence 1


\subsection{Add to Own State}

\opdef{1}{1}

Interprets the first 32 bytes of the instruction tag as an unsigned integer.
Calculates the index of the writable state to operate on as the remainder of integer division by the number of writable states.

Adds the value in register \texttt{arg0} and the current value in the target writable state then stores the sum back into the writable state.

\subsection{Broadcast Intra Message If}

\opdef{1}{1}

If `arg[0]' is true, encodes the instruction's tag and register states into a message, which then broadcasts to every other cardinal within the cell.


\subsection{Multiply Own State}

\opdef{5}{1}

Multiplies cell's own writable state by `arg[0]'

\subsection{Read Neighbor State}

\opdef{10}{1}

Reads neighbor's readable state and stores it in `arg[0]'.

Which neighbor the state is read from is determined algorithmically via the instruction's tag.

\subsection{Read Own State}

\opdef{20}{1}

Reads own readable state and stores it in `arg[0]'.

\subsection{Send Inter Message If}

\opdef{5}{1}

If `arg[0]' is true, sends cell's state to a neighbor cell as determined by the peripheral.

\subsection{Send Intra Message If}

\opdef{5}{1}

If `arg[0]' is true, sends cell's state to a cardinal within the cell as determined by the peripheral.

\subsection{Write Own State If}

\opdef{5}{2}

If `arg[1]' is true, writes cell's state into `arg[0]'.

